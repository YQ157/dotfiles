" =============================================================================
" 基础显示设置 (帮助你准确定位代码)
" =============================================================================
syntax on                   " 开启语法高亮，根据编程语言关键字显示不同颜色
set number                  " 在屏幕左侧显示行号，方便定位错误行
set cursorline              " 在光标所在行显示一条横线，防止在满屏代码中看花眼
set ruler                   " 在右下角显示光标当前的行号和列号
set wrap                    " 如果一行代码太长，自动折行显示，不超出屏幕边界
set showmatch               " 当光标移动到括号时，自动高亮匹配的另一半括号
set encoding=utf-8			" 强制 UTF-8 编码

" =============================================================================
" 缩进与格式
" =============================================================================
set tabstop=4               " Tab 键宽度
set shiftwidth=4            " 自动缩进 4 个空格
set expandtab               " Tab 键转为空格
set autoindent              " 换行时，光标自动移动到与上一行对齐的位置
set smartindent             " 智能缩进

" =============================================================================
" 按键映射
" =============================================================================
" 自动展开成代码框并缩进
inoremap {<CR> {<CR>}<Esc>O
" 将Normal模式的Esc映射为取消高亮
nnoremap <Esc> :noh<CR><Esc>
" 设置括号补全
inoremap () ()<Left>
inoremap "" ""<Left>
inoremap [] []<Left>
inoremap '' ''<Left>

" =============================================================================
" 搜索设置 (提高查找代码的效率)
" =============================================================================
set hlsearch                " 搜索完成后，高亮显示所有匹配到的结果
set incsearch               " 边输入搜索词，边实时跳转到第一个匹配项
set ignorecase              " 搜索时默认不区分大小写
set smartcase               " 若搜索词包含大写字母，则转为区分大小写搜索

" =============================================================================
" 系统集成 (虽然硬核，但建议保留与系统的唯一联系)
" =============================================================================
set clipboard=unnamed       " 让 Vim 的复制粘贴寄存器与 Mac 系统的剪贴板同步

" =============================================================================
" 自动化功能：F5 一键编译运行 (你的“刷题引擎”)
" =============================================================================
" 将键盘上的 F5 键映射为调用我们定义的 CompileRunGpp 函数
map <F5> :call CompileRunGpp()<CR>

" 定义编译运行函数，! 表示如果函数已存在则覆盖
func! CompileRunGpp()
    " 执行 :w 命令，在编译前先强制保存当前文件，防止运行旧代码
    execute "w"
    " 如果当前文件的类型是 C++ (cpp)
    if &filetype == 'cpp'
        " 调用外部 g++ 编译器，使用 C++17 标准，显示所有警告 (-Wall)，编译成功后直接运行
        " % 代表当前文件名，%< 代表去掉后缀的文件名
        execute "!g++ -std=c++17 -Wall -g -fsanitize=address % -o runner  && ./runner"
    " 如果当前文件的类型是 Python (python)
    elseif &filetype == 'python'
        " 调用外部 python3 解释器直接运行当前文件
        execute "!python3 %"
    " 结束判断条件
    endif
" 结束函数定义
endfunc

" =============================================================================
" 自动加载模板：新建 .cpp 文件时，自动读取模板文件内容
" =============================================================================
" --- 路径设置 ---
" <sfile>: 当前被 source 的文件，软链接地址
" expand(':p'): 转为绝对路径
" resolve() 解析软链接，找到真实物理路径
" fnamemodify(':h') 去掉文件名，只保留目录，Head
" g 表示全局作用域，s表示脚本作用域
let s:current_dir = fnamemodify(resolve(expand('<sfile>:p')), ':h')
let g:template_dir = s:current_dir . '/templates/'
" autocmd: 自动化命令
" BufNewFile: 触发时机是“创建一个不存在的新文件时”
" *.cpp: 匹配所有以 .cpp 结尾的文件
" silent!: 如果模板文件不存在，不报错
" execute: 动态拼接命令
" "0read": 从第 0 行开始读取 (Read) 后面路径文件的内容
autocmd BufNewFile *.cpp silent! 
    \ execute "0read" . g:template_dir . "algorithm.cpp" 
    \ | call search('void solve') | normal! kzz
